package annotation

import (
	"fmt"
	"math"
	"strconv"
	"strings"
	"text/scanner"
	"unicode"

	"github.com/gopherd/doge/encoding"
	"google.golang.org/protobuf/compiler/protogen"
)

func Generate(gen *protogen.Plugin, f *protogen.File) error {
	annotations := make(map[string][]*associatedAnnotation)
	for _, m := range f.Messages {
		creator := func(ann Annotation) *associatedAnnotation {
			a := newAssociatedAnnotation(f, ann)
			a.oneof.message = m
			return a
		}
		if err := parseAnnotations(annotations, creator, string(m.Comments.Leading)); err != nil {
			println("gopherd.Generate: parse message annotation error: " + err.Error())
		}
	}
	for _, m := range f.Enums {
		creator := func(ann Annotation) *associatedAnnotation {
			a := newAssociatedAnnotation(f, ann)
			a.oneof.enum = m
			return a
		}
		if err := parseAnnotations(annotations, creator, string(m.Comments.Leading)); err != nil {
			println("gopherd.Generate: parse enum annotation error: " + err.Error())
		}
	}
	if len(annotations) == 0 {
		return nil
	}
	filename := f.GeneratedFilenamePrefix + ".gopherd.go"
	g := gen.NewGeneratedFile(filename, f.GoImportPath)
	g.P("// Code generated by protoc-gen-gopherd. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)
	g.P()
	g.P("const (")
	for _, anns := range annotations {
		for _, ann := range anns {
			switch ann.annotation.Name() {
			case AnnotationMessageType:
				if ann.oneof.message == nil {
					continue
				}
				messageType := ann.annotation.(*MessageType)
				if messageType.Oneof.Empty {
					println("@MessageType: no value not supported yet")
				}
				if messageType.Oneof.Source != "" {
					println("@MessageType: string value not supported yet")
				}
				g.P("\t", ann.oneof.message.GoIdent.GoName, "Type = ", messageType.Oneof.Value)
			}
		}
	}
	g.P(")")
	g.P()

	for _, anns := range annotations {
		for _, ann := range anns {
			switch ann.annotation.Name() {
			case AnnotationMessageType:
				if ann.oneof.message == nil {
					continue
				}
				messageType := ann.annotation.(*MessageType)
				if messageType.Oneof.Empty {
					continue
				}
				if messageType.Oneof.Source != "" {
					continue
				}
				name := ann.oneof.message.GoIdent.GoName
				g.P("\tfunc (*", name, ") GetMessageType() int32 { return ", name, "Type }")
			}
		}
	}
	return nil
}

func parseAnnotations(
	annotations map[string][]*associatedAnnotation,
	creator func(Annotation) *associatedAnnotation,
	comment string,
) error {
	for _, line := range strings.Split(strings.TrimSuffix(comment, "\n"), "\n") {
		if ann, err := parseAnnotation(strings.TrimSpace(line)); err != nil {
			return err
		} else if ann != nil {
			annotations[ann.Name()] = append(annotations[ann.Name()], creator(ann))
		}
	}
	return nil
}

type associatedAnnotation struct {
	annotation Annotation

	file  *protogen.File
	oneof struct {
		message *protogen.Message
		enum    *protogen.Enum
	}
}

func newAssociatedAnnotation(f *protogen.File, ann Annotation) *associatedAnnotation {
	return &associatedAnnotation{
		annotation: ann,
		file:       f,
	}
}

// annotation format:
//		@Name
//		@Name(arguments...)
// comma-seperated each argument should be one of:
//	literal value: integer, float, char, string
//	ident: valid identity name
//	key-value pair: $key = $value
//		where $key is an ident or a string literal, $value is an ident or any literal
func parseAnnotation(line string) (ann Annotation, err error) {
	if len(line) < 2 || line[0] != '@' {
		// not an annotation
		return
	}
	var name string
	if end := strings.Index(line, "("); end > 0 {
		name = line[1:end]
		line = line[end:]
	} else {
		name = line[1:]
		line = ""
	}
	if !isIdent(name) {
		// not an annotation
		return
	}

	var (
		parser encoding.Parser
		s      scanner.Scanner
	)
	s.Init(strings.NewReader(line))
	s.Mode = scanner.ScanIdents | scanner.ScanFloats | scanner.ScanChars | scanner.ScanStrings
	parser.Init(&s)

	switch name {
	case AnnotationMessageType:
		return parseMessageTypeAnnotation(&parser)
	default:
		// ignore unknown annotation type
		return
	}
}

func isIdent(s string) bool {
	if len(s) == 0 {
		return false
	}
	for i, c := range s {
		if !isIdentRune(c, i) {
			return false
		}
	}
	return true
}

func isIdentRune(ch rune, i int) bool {
	return ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch) && i > 0
}

// Annotation interface
type Annotation interface {
	Name() string
}

const (
	AnnotationMessageType = "MessageType"
)

// @MessageType
// @MessageType(value: int32)
// @MessageType(source: string)
type MessageType struct {
	Oneof struct {
		Empty  bool
		Value  int32
		Source string
	}
}

func (*MessageType) Name() string { return AnnotationMessageType }

func parseMessageTypeAnnotation(parser *encoding.Parser) (ann Annotation, err error) {
	if err = parser.Next(); err != nil {
		return
	}
	m := &MessageType{}
	if parser.Tok == scanner.EOF {
		m.Oneof.Empty = true
		ann = m
		return
	}
	if err = parser.Expect('('); err != nil {
		return
	}
	switch parser.Tok {
	case scanner.String:
		m.Oneof.Source = parser.Lit
	case scanner.Int:
		var value int64
		value, err = strconv.ParseInt(parser.Lit, 0, 32)
		if err != nil {
			return
		}
		if value > math.MaxInt32 || value < math.MinInt32 {
			err = fmt.Errorf("MessageType: value %d out of range [%d, %d]", value, math.MinInt32, math.MaxInt32)
			return
		}
		m.Oneof.Value = int32(value)
	default:
		err = fmt.Errorf("expect a string or integer, but got %s at %s", parser.Lit, parser.Pos)
		return
	}
	if err = parser.Next(); err != nil {
		return
	}
	if err = parser.Expect(')'); err != nil {
		return
	}
	if err = parser.Expect(scanner.EOF); err != nil {
		return
	}

	ann = m
	return
}
